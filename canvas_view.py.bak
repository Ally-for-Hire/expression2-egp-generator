from __future__ import annotations

from typing import Dict, List, Optional, Set, Tuple

import tkinter as tk

import config
from model import Project, Shape


Point = Tuple[float, float]


class CanvasView:
    def __init__(
        self,
        master: tk.Widget,
        project: Project,
        on_selection_changed=None,
        on_project_changed=None,
        on_view_changed=None,
        on_shape_created=None,
    ) -> None:
        self.project = project
        self.canvas = tk.Canvas(master, bg=config.THEME["bg"], highlightthickness=0)

        self.tool = "select"
        self.settings = {
            "stroke": config.DEFAULT_STROKE,
            "stroke_width": config.DEFAULT_STROKE_WIDTH,
            "fill": config.DEFAULT_FILL,
            "text": config.DEFAULT_TEXT,
            "font": config.DEFAULT_FONT,
            "font_size": config.DEFAULT_FONT_SIZE,
            "align": "left",
        }

        self.active_layer_id = project.active_layer_id

        self.zoom = 1.0
        self.pan_x = 0.0
        self.pan_y = 0.0
        self.auto_fit = True

        self.grid_minor = config.GRID_MINOR_STEP
        self.grid_major = config.GRID_MAJOR_STEP

        self._shape_items: Dict[str, List[int]] = {}
        self._item_to_shape: Dict[int, str] = {}
        self._selected_shape_ids: Set[str] = set()
        self._on_selection_changed = on_selection_changed
        self._on_project_changed = on_project_changed
        self._on_view_changed = on_view_changed
        self._on_shape_created = on_shape_created

        self._drag_start: Optional[Point] = None
        self._temp_item: Optional[int] = None
        self._selection_box: Optional[int] = None
        self._poly_points: List[Point] = []
        self._drag_vertex: Optional[Tuple[str, int]] = None

        self.canvas.bind("<Configure>", self._on_resize)
        self.canvas.bind("<ButtonPress-1>", self._on_left_press)
        self.canvas.bind("<B1-Motion>", self._on_left_drag)
        self.canvas.bind("<ButtonRelease-1>", self._on_left_release)
        self.canvas.bind("<Double-Button-1>", self._on_left_double)
        self.canvas.bind("<ButtonPress-3>", self._on_right_press)
        self.canvas.bind("<B3-Motion>", self._on_right_drag)
        self.canvas.bind("<MouseWheel>", self._on_mouse_wheel)
        self.canvas.bind("<KeyPress-Escape>", self._on_escape)
        self.canvas.bind("<KeyPress-Return>", self._on_enter)
        self.canvas.bind("<ButtonPress-2>", self._on_middle_press)
        self.canvas.bind("<B2-Motion>", self._on_middle_drag)
        self.canvas.focus_set()

    @property
    def selected_shape_ids(self) -> Set[str]:
        return set(self._selected_shape_ids)

    def set_project(self, project: Project) -> None:
        self.project = project
        self.active_layer_id = project.active_layer_id
        self._selected_shape_ids.clear()
        self.auto_fit = True
        self.fit_to_view()
        self.draw()

    def set_tool(self, tool: str) -> None:
        self.tool = tool
        self._clear_temp()

    def set_active_layer(self, layer_id: str) -> None:
        self.active_layer_id = layer_id

    def set_grid(self, minor: int, major: int) -> None:
        self.grid_minor = max(5, int(minor))
        self.grid_major = max(self.grid_minor, int(major))
        self.draw()

    def update_settings(self, updates: Dict[str, object]) -> None:
        self.settings.update(updates)

    def apply_settings_to_selected(self) -> None:
        if not self._selected_shape_ids:
            return
        for shape_id in list(self._selected_shape_ids):
            shape = self._find_shape(shape_id)
            if not shape:
                continue
            shape.stroke = str(self.settings["stroke"])
            shape.stroke_width = int(self.settings["stroke_width"])
            shape.fill = str(self.settings["fill"]) if self.settings.get("fill") else None
            shape.text = str(self.settings["text"])
            shape.font = str(self.settings["font"])
            shape.font_size = int(self.settings["font_size"])
            shape.align = str(self.settings.get("align", "left"))
        self.draw()
        self._notify_project_changed()

    def set_selected_shapes(self, shape_ids: Set[str]) -> None:
        self._selected_shape_ids = set(shape_ids)
        self._update_selection_highlight()
        if self._on_selection_changed:
            shapes = [self._find_shape(shape_id) for shape_id in self._selected_shape_ids]
            self._on_selection_changed([shape for shape in shapes if shape is not None])

    def move_selected_to_center_offset(self, offset: Point) -> None:
        if not self._selected_shape_ids:
            return
        res_w, res_h = self.project.resolution
        target_world = (offset[0] + res_w / 2, offset[1] + res_h / 2)
        current = self._selection_center()
        if current is None:
            return
        dx = target_world[0] - current[0]
        dy = target_world[1] - current[1]
        for shape_id in list(self._selected_shape_ids):
            shape = self._find_shape(shape_id)
            if not shape:
                continue
            shape.points = [(p[0] + dx, p[1] + dy) for p in shape.points]
        self.draw()
        self._notify_project_changed()

    def selection_center_offset(self) -> Optional[Point]:
        center = self._selection_center()
        if center is None:
            return None
        res_w, res_h = self.project.resolution
        return (center[0] - res_w / 2, center[1] - res_h / 2)

    def fit_to_view(self) -> None:
        width = max(1, self.canvas.winfo_width())
        height = max(1, self.canvas.winfo_height())
        res_w, res_h = self.project.resolution
        self.zoom = min(width / res_w, height / res_h)
        self.pan_x = (width - res_w * self.zoom) / 2
        self.pan_y = (height - res_h * self.zoom) / 2
        self.auto_fit = True
        self._notify_view_changed()

    def zoom_in(self) -> None:
        self._zoom_at_center(config.ZOOM_STEP)

    def zoom_out(self) -> None:
        self._zoom_at_center(1 / config.ZOOM_STEP)

    def draw(self) -> None:
        self.canvas.delete("grid")
        self.canvas.delete("shape")
        self.canvas.delete("selection")
        self._shape_items.clear()
        self._item_to_shape.clear()

        self._draw_grid()
        for layer in self.project.layers:
            if not layer.visible:
                continue
            for shape in layer.shapes:
                item_ids = self._draw_shape(shape)
                if item_ids:
                    self._shape_items[shape.id] = item_ids
                    for item_id in item_ids:
                        self._item_to_shape[item_id] = shape.id
        self._update_selection_highlight()

    def _draw_grid(self) -> None:
        width = self.canvas.winfo_width()
        height = self.canvas.winfo_height()
        if width <= 0 or height <= 0:
            return
        top_left = self.screen_to_world((0, 0))
        bottom_right = self.screen_to_world((width, height))
        min_x = max(0, int(top_left[0]) - self.grid_minor)
        min_y = max(0, int(top_left[1]) - self.grid_minor)
        max_x = min(self.project.resolution[0], int(bottom_right[0]) + self.grid_minor)
        max_y = min(self.project.resolution[1], int(bottom_right[1]) + self.grid_minor)

        minor = self.grid_minor
        major = self.grid_major

        start_x = (min_x // minor) * minor
        start_y = (min_y // minor) * minor

        for x in range(start_x, max_x + 1, minor):
            color = config.THEME["grid_major"] if x % major == 0 else config.THEME["grid"]
            p1 = self.world_to_screen((x, min_y))
            p2 = self.world_to_screen((x, max_y))
            self.canvas.create_line(p1[0], p1[1], p2[0], p2[1], fill=color, tags="grid")

        for y in range(start_y, max_y + 1, minor):
            color = config.THEME["grid_major"] if y % major == 0 else config.THEME["grid"]
            p1 = self.world_to_screen((min_x, y))
            p2 = self.world_to_screen((max_x, y))
            self.canvas.create_line(p1[0], p1[1], p2[0], p2[1], fill=color, tags="grid")

        res_w, res_h = self.project.resolution
        tl = self.world_to_screen((0, 0))
        br = self.world_to_screen((res_w, res_h))
        self.canvas.create_rectangle(tl[0], tl[1], br[0], br[1], outline=config.THEME["accent"], width=1, tags="grid")
        center = self.world_to_screen((res_w / 2, res_h / 2))
        self.canvas.create_line(tl[0], center[1], br[0], center[1], fill=config.THEME["accent_alt"], width=2, tags="grid")
        self.canvas.create_line(center[0], tl[1], center[0], br[1], fill=config.THEME["accent_alt"], width=2, tags="grid")

    def _draw_shape(self, shape: Shape) -> List[int]:
        if not shape.points:
            return []
        item_ids: List[int] = []
        stroke_width = max(1, int(shape.stroke_width * self.zoom))
        layer_color = self._layer_color_for_shape(shape)
        stroke = layer_color or shape.stroke
        fill = layer_color or shape.fill

        if shape.kind == "line" and len(shape.points) >= 2:
            p1 = self.world_to_screen(shape.points[0])
            p2 = self.world_to_screen(shape.points[1])
            item_ids.append(
                self.canvas.create_line(
                    p1[0], p1[1], p2[0], p2[1],
                    fill=stroke,
                    width=stroke_width,
                    tags="shape",
                )
            )
        elif shape.kind in ("rect", "box") and len(shape.points) >= 2:
            p1 = self.world_to_screen(shape.points[0])
            p2 = self.world_to_screen(shape.points[1])
            fill_color = fill if shape.kind == "box" else ""
            item_ids.append(
                self.canvas.create_rectangle(
                    p1[0], p1[1], p2[0], p2[1],
                    outline=stroke,
                    width=stroke_width,
                    fill=fill_color,
                    tags="shape",
                )
            )
        elif shape.kind in ("circle", "circle_filled") and len(shape.points) >= 2:
            p1 = self.world_to_screen(shape.points[0])
            p2 = self.world_to_screen(shape.points[1])
            fill_color = fill if shape.kind == "circle_filled" else ""
            item_ids.append(
                self.canvas.create_oval(
                    p1[0], p1[1], p2[0], p2[1],
                    outline=stroke,
                    width=stroke_width,
                    fill=fill_color,
                    tags="shape",
                )
            )
        elif shape.kind == "poly" and len(shape.points) >= 3:
            pts = []
            for point in shape.points:
                sp = self.world_to_screen(point)
                pts.extend([sp[0], sp[1]])
            fill_color = fill or ""
            item_ids.append(
                self.canvas.create_polygon(
                    pts,
                    outline=stroke,
                    width=stroke_width,
                    fill=fill_color,
                    tags="shape",
                )
            )
        elif shape.kind == "text":
            p = self.world_to_screen(shape.points[0])
            size = max(1, int(shape.font_size * self.zoom))
            anchor = "w" if shape.align == "left" else "center" if shape.align == "center" else "e"
            font = (shape.font or config.DEFAULT_FONT, size)
            item_ids.append(
                self.canvas.create_text(
                    p[0], p[1],
                    text=shape.text,
                    fill=stroke,
                    anchor=anchor,
                    font=font,
                    tags="shape",
                )
            )
        return item_ids

    def world_to_screen(self, point: Point) -> Point:
        return (point[0] * self.zoom + self.pan_x, point[1] * self.zoom + self.pan_y)

    def screen_to_world(self, point: Point) -> Point:
        return ((point[0] - self.pan_x) / self.zoom, (point[1] - self.pan_y) / self.zoom)

    def _on_resize(self, _event: tk.Event) -> None:
        if self.auto_fit:
            self.fit_to_view()
        self.draw()

    def _on_left_press(self, event: tk.Event) -> None:
        self.canvas.focus_set()
        if self.tool == "select":
            vertex = self._find_vertex_at(event)
            if vertex:
                self._drag_vertex = vertex
                return
            self._drag_start = (event.x, event.y)
            self._select_at(event)
            return

        if self._active_layer_locked():
            return

        world = self._snap_if_ctrl(self.screen_to_world((event.x, event.y)), event)
        self._drag_start = world
        if self.tool in ("line", "rect", "box", "circle", "circle_filled"):
            self._temp_item = self._create_temp_shape(world, world)
        elif self.tool == "poly":
            self._poly_points.append(world)
            self._update_poly_preview()
        elif self.tool == "text":
            self._create_text_shape(world)

    def _on_left_drag(self, event: tk.Event) -> None:
        if self.tool == "select":
            if self._drag_vertex:
                self._drag_vertex_to(event)
                return
            if not self._drag_start:
                return
            self._update_selection_box(event)
            return
        if self.tool not in ("line", "rect", "box", "circle", "circle_filled"):
            return
        if not self._drag_start or self._temp_item is None:
            return
        world = self._snap_if_ctrl(self.screen_to_world((event.x, event.y)), event)
        self._update_temp_shape(self._drag_start, world)

    def _on_left_release(self, event: tk.Event) -> None:
        if self.tool == "select":
            if self._drag_vertex:
                self._drag_vertex = None
                self._notify_project_changed()
                return
            if self._drag_start:
                self._finalize_selection_box(event)
            return
        if self.tool not in ("line", "rect", "box", "circle", "circle_filled"):
            return
        if not self._drag_start:
            return
        world = self._snap_if_ctrl(self.screen_to_world((event.x, event.y)), event)
        self._finalize_drag_shape(self._drag_start, world)
        self._drag_start = None

    def _on_left_double(self, _event: tk.Event) -> None:
        if self.tool == "poly":
            self._finish_poly()

    def _on_escape(self, _event: tk.Event) -> None:
        self._clear_temp()

    def _on_enter(self, _event: tk.Event) -> None:
        if self.tool == "poly":
            self._finish_poly()

    def _on_right_press(self, event: tk.Event) -> None:
        self._drag_start = (event.x, event.y)

    def _on_right_drag(self, event: tk.Event) -> None:
        if self._drag_start is None:
            return
        dx = event.x - self._drag_start[0]
        dy = event.y - self._drag_start[1]
        self.pan_x += dx
        self.pan_y += dy
        self._drag_start = (event.x, event.y)
        self.auto_fit = False
        self.draw()
        self._notify_view_changed()

    def _on_middle_press(self, event: tk.Event) -> None:
        self._drag_start = (event.x, event.y)

    def _on_middle_drag(self, event: tk.Event) -> None:
        self._on_right_drag(event)

    def _on_mouse_wheel(self, event: tk.Event) -> None:
        factor = config.ZOOM_STEP if event.delta > 0 else 1 / config.ZOOM_STEP
        self._zoom_at(event.x, event.y, factor)

    def _zoom_at_center(self, factor: float) -> None:
        width = self.canvas.winfo_width()
        height = self.canvas.winfo_height()
        self._zoom_at(width / 2, height / 2, factor)

    def _zoom_at(self, x: float, y: float, factor: float) -> None:
        old_zoom = self.zoom
        new_zoom = min(config.ZOOM_MAX, max(config.ZOOM_MIN, self.zoom * factor))
        if new_zoom == old_zoom:
            return
        world = self.screen_to_world((x, y))
        self.zoom = new_zoom
        self.pan_x = x - world[0] * self.zoom
        self.pan_y = y - world[1] * self.zoom
        self.auto_fit = False
        self.draw()
        self._notify_view_changed()

    def _select_at(self, event: tk.Event) -> None:
        item = self.canvas.find_closest(event.x, event.y)
        if not item:
            self.set_selected_shapes(set())
            return
        shape_id = self._item_to_shape.get(item[0])
        if shape_id:
            self.set_selected_shapes({shape_id})

    def _update_selection_highlight(self) -> None:
        self.canvas.delete("selection")
        if not self._selected_shape_ids:
            return
        for shape_id in self._selected_shape_ids:
            shape = self._find_shape(shape_id)
            if not shape or not shape.points:
                continue
            bounds = self._shape_bounds(shape)
            if not bounds:
                continue
            p1 = self.world_to_screen(bounds[0])
            p2 = self.world_to_screen(bounds[1])
            self.canvas.create_rectangle(
                p1[0], p1[1], p2[0], p2[1],
                outline=config.THEME["accent_alt"],
                dash=(4, 2),
                tags="selection",
            )

    def _shape_bounds(self, shape: Shape) -> Optional[Tuple[Point, Point]]:
        if shape.kind == "text":
            x, y = shape.points[0]
            return (x - 10, y - 10), (x + 10, y + 10)
        if not shape.points:
            return None
        xs = [p[0] for p in shape.points]
        ys = [p[1] for p in shape.points]
        return (min(xs), min(ys)), (max(xs), max(ys))

    def _create_temp_shape(self, start: Point, end: Point) -> Optional[int]:
        if self.tool == "line":
            p1 = self.world_to_screen(start)
            p2 = self.world_to_screen(end)
            return self.canvas.create_line(p1[0], p1[1], p2[0], p2[1], fill=self.settings["stroke"], dash=(4, 2), tags="shape")
        if self.tool in ("rect", "box"):
            p1 = self.world_to_screen(start)
            p2 = self.world_to_screen(end)
            return self.canvas.create_rectangle(p1[0], p1[1], p2[0], p2[1], outline=self.settings["stroke"], dash=(4, 2), tags="shape")
        if self.tool in ("circle", "circle_filled"):
            p1 = self.world_to_screen(start)
            p2 = self.world_to_screen(end)
            return self.canvas.create_oval(p1[0], p1[1], p2[0], p2[1], outline=self.settings["stroke"], dash=(4, 2), tags="shape")
        return None

    def _update_temp_shape(self, start: Point, end: Point) -> None:
        if self._temp_item is None:
            return
        p1 = self.world_to_screen(start)
        p2 = self.world_to_screen(end)
        self.canvas.coords(self._temp_item, p1[0], p1[1], p2[0], p2[1])

    def _finalize_drag_shape(self, start: Point, end: Point) -> None:
        if self._active_layer_locked():
            self._clear_temp()
            return
        if self._temp_item is not None:
            self.canvas.delete(self._temp_item)
            self._temp_item = None
        if start == end:
            return
        shape = self._shape_from_drag(start, end)
        if shape is None:
            return
        layer = self.project.get_layer(self.active_layer_id)
        if not layer:
            return
        layer.shapes.append(shape)
        if self._on_shape_created:
            self._on_shape_created(shape)
        self.draw()
        self._notify_project_changed()

    def _shape_from_drag(self, start: Point, end: Point) -> Optional[Shape]:
        shape_id = self.project.new_shape_id()
        stroke = str(self.settings["stroke"])
        stroke_width = int(self.settings["stroke_width"])
        fill = str(self.settings["fill"]) if self.settings.get("fill") else None
        if self.tool == "line":
            return Shape(id=shape_id, kind="line", points=[start, end], stroke=stroke, stroke_width=stroke_width)
        if self.tool == "rect":
            return Shape(id=shape_id, kind="rect", points=[start, end], stroke=stroke, stroke_width=stroke_width)
        if self.tool == "box":
            return Shape(id=shape_id, kind="box", points=[start, end], stroke=stroke, stroke_width=stroke_width, fill=fill)
        if self.tool == "circle":
            return Shape(id=shape_id, kind="circle", points=[start, end], stroke=stroke, stroke_width=stroke_width)
        if self.tool == "circle_filled":
            return Shape(id=shape_id, kind="circle_filled", points=[start, end], stroke=stroke, stroke_width=stroke_width, fill=fill)
        return None

    def _create_text_shape(self, point: Point) -> None:
        if self._active_layer_locked():
            return
        shape = Shape(
            id=self.project.new_shape_id(),
            kind="text",
            points=[point],
            stroke=str(self.settings["stroke"]),
            stroke_width=int(self.settings["stroke_width"]),
            text=str(self.settings["text"]),
            font=str(self.settings["font"]),
            font_size=int(self.settings["font_size"]),
            align=str(self.settings.get("align", "left")),
        )
        layer = self.project.get_layer(self.active_layer_id)
        if not layer:
            return
        layer.shapes.append(shape)
        if self._on_shape_created:
            self._on_shape_created(shape)
        self.draw()
        self._notify_project_changed()

    def _update_poly_preview(self) -> None:
        if self._temp_item is not None:
            self.canvas.delete(self._temp_item)
        if len(self._poly_points) < 2:
            return
        points = []
        for point in self._poly_points:
            sp = self.world_to_screen(point)
            points.extend([sp[0], sp[1]])
        self._temp_item = self.canvas.create_line(*points, fill=self.settings["stroke"], dash=(4, 2), tags="shape")

    def _finish_poly(self) -> None:
        if len(self._poly_points) < 3:
            self._clear_temp()
            return
        shape = Shape(
            id=self.project.new_shape_id(),
            kind="poly",
            points=list(self._poly_points),
            stroke=str(self.settings["stroke"]),
            stroke_width=int(self.settings["stroke_width"]),
            fill=str(self.settings["fill"]) if self.settings.get("fill") else None,
        )
        layer = self.project.get_layer(self.active_layer_id)
        if not layer:
            return
        layer.shapes.append(shape)
        if self._on_shape_created:
            self._on_shape_created(shape)
        self._clear_temp()
        self.draw()
        self._notify_project_changed()

    def _notify_project_changed(self) -> None:
        if self._on_project_changed:
            self._on_project_changed()

    def _notify_view_changed(self) -> None:
        if self._on_view_changed:
            self._on_view_changed()

    def finish_poly(self) -> None:
        if self.tool == "poly":
            self._finish_poly()

    def _clear_temp(self) -> None:
        if self._temp_item is not None:
            self.canvas.delete(self._temp_item)
        self._temp_item = None
        self._poly_points.clear()
        if self._selection_box is not None:
            self.canvas.delete(self._selection_box)
        self._selection_box = None

    def _find_shape(self, shape_id: str) -> Optional[Shape]:
        for layer in self.project.layers:
            for shape in layer.shapes:
                if shape.id == shape_id:
                    return shape
        return None

    def _layer_color_for_shape(self, shape: Shape) -> Optional[str]:
        for layer in self.project.layers:
            if shape in layer.shapes:
                return layer.color
        return None

    def _active_layer_locked(self) -> bool:
        layer = self.project.get_layer(self.active_layer_id)
        return bool(layer and layer.locked)

    def _update_selection_box(self, event: tk.Event) -> None:
        if not self._drag_start:
            return
        if self._selection_box is None:
            self._selection_box = self.canvas.create_rectangle(
                self._drag_start[0], self._drag_start[1], event.x, event.y,
                outline=config.THEME["accent"], dash=(4, 2), tags="selection",
            )
        else:
            self.canvas.coords(self._selection_box, self._drag_start[0], self._drag_start[1], event.x, event.y)

    def _finalize_selection_box(self, event: tk.Event) -> None:
        if not self._drag_start:
            return
        start = self._drag_start
        end = (event.x, event.y)
        if self._selection_box is not None:
            self.canvas.delete(self._selection_box)
        self._selection_box = None
        self._drag_start = None
        if start == end:
            return
        world_start = self.screen_to_world(start)
        world_end = self.screen_to_world(end)
        min_x = min(world_start[0], world_end[0])
        max_x = max(world_start[0], world_end[0])
        min_y = min(world_start[1], world_end[1])
        max_y = max(world_start[1], world_end[1])
        selected: Set[str] = set()
        for layer in self.project.layers:
            if not layer.visible:
                continue
            for shape in layer.shapes:
                bounds = self._shape_bounds(shape)
                if not bounds:
                    continue
                b1, b2 = bounds
                if b2[0] < min_x or b1[0] > max_x or b2[1] < min_y or b1[1] > max_y:
                    continue
                selected.add(shape.id)
        self.set_selected_shapes(selected)

    def delete_selected(self) -> None:
        if not self._selected_shape_ids:
            return
        for layer in self.project.layers:
            layer.shapes = [shape for shape in layer.shapes if shape.id not in self._selected_shape_ids]
        self.set_selected_shapes(set())
        self.draw()
        self._notify_project_changed()

    def mirror_selected(self, axis: str, copy: bool = True) -> None:
        if not self._selected_shape_ids:
            return
        res_w, res_h = self.project.resolution
        new_ids: Set[str] = set()
        for layer in self.project.layers:
            new_shapes: List[Shape] = []
            for shape in layer.shapes:
                if shape.id not in self._selected_shape_ids:
                    continue
                target = shape
                if copy:
                    target = Shape.from_dict(shape.to_dict())
                    target.id = self.project.new_shape_id()
                    new_ids.add(target.id)
                mirrored = []
                for x, y in target.points:
                    if axis == "x":
                        mirrored.append((res_w - x, y))
                    elif axis == "y":
                        mirrored.append((x, res_h - y))
                    else:
                        mirrored.append((x, y))
                target.points = mirrored
                if copy:
                    new_shapes.append(target)
            if copy and new_shapes:
                layer.shapes.extend(new_shapes)
        if copy:
            self.set_selected_shapes(new_ids)
        self.draw()
        self._notify_project_changed()

    def _ctrl_down(self, event: tk.Event) -> bool:
        return bool(event.state & 0x0004)

    def _snap_if_ctrl(self, world: Point, event: tk.Event) -> Point:
        if not self._ctrl_down(event):
            return world
        step = self.grid_minor
        if step <= 0:
            return world
        return (round(world[0] / step) * step, round(world[1] / step) * step)

    def _find_vertex_at(self, event: tk.Event) -> Optional[Tuple[str, int]]:
        world = self.screen_to_world((event.x, event.y))
        threshold = 8 / max(self.zoom, 0.001)
        for layer in self.project.layers:
            if not layer.visible:
                continue
            for shape in layer.shapes:
                if shape.kind != "poly":
                    continue
                for idx, point in enumerate(shape.points):
                    dx = point[0] - world[0]
                    dy = point[1] - world[1]
                    if (dx * dx + dy * dy) ** 0.5 <= threshold:
                        self.set_selected_shapes({shape.id})
                        return (shape.id, idx)
        return None

    def _drag_vertex_to(self, event: tk.Event) -> None:
        if not self._drag_vertex:
            return
        shape = self._find_shape(self._drag_vertex[0])
        if not shape:
            return
        world = self._snap_if_ctrl(self.screen_to_world((event.x, event.y)), event)
        shape.points[self._drag_vertex[1]] = world
        self.draw()

    def _selection_center(self) -> Optional[Point]:
        if not self._selected_shape_ids:
            return None
        xs: List[float] = []
        ys: List[float] = []
        for shape_id in self._selected_shape_ids:
            shape = self._find_shape(shape_id)
            if not shape:
                continue
            for point in shape.points:
                xs.append(point[0])
                ys.append(point[1])
        if not xs or not ys:
            return None
        return (sum(xs) / len(xs), sum(ys) / len(ys))
